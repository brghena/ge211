#pragma once

#include "ge211_error.hxx"
#include "ge211_if_cpp.hxx"
#include "ge211_forward.hxx"
#include "ge211_type_traits.hxx"

#include <cstdint>
#include <limits>
#include <memory>
#include <random>
#include <type_traits>

namespace ge211 {
namespace detail {
namespace random {

using Generator = std::mt19937_64;

Generator
construct_generator();

template <class RESULT_TYPE>
struct Random_engine
{
    using result_type = RESULT_TYPE;

    virtual result_type next() = 0;

    virtual bool is_sticky() const;

    virtual ~Random_engine() = default;
};

template <class RESULT_TYPE, class ENABLE = void>
struct Distribution
{
    struct
    {
        RESULT_TYPE contents;
    } error = "ge211::Random_source<RESULT_TYPE> requires "
              "RESULT_TYPE to be a built-in arithmetic type like int "
              "or double.";
};

template <class RESULT_TYPE>
class Distribution<
        RESULT_TYPE,
        std::enable_if_t<std::is_integral<RESULT_TYPE>::value>
>
{
public:
    using result_type = RESULT_TYPE;

private:
    using impl_type = std::uniform_int_distribution<result_type>;
    impl_type impl_;

public:
    Distribution(result_type min, result_type max)
            : impl_{min, max}
    { }

    Distribution(result_type end)
            : Distribution{0, end - 1}
    { }

    result_type operator()(Generator &gen)
    {
        return impl_(gen);
    }
};


template <class RESULT_TYPE>
class Distribution<
        RESULT_TYPE,
        std::enable_if_t<std::is_floating_point<RESULT_TYPE>::value>>
{
public:
    using result_type = RESULT_TYPE;

private:
    using impl_type = std::uniform_real_distribution<result_type>;
    impl_type impl_;

public:
    Distribution(result_type min, result_type max)
            : impl_{min, max}
    { }

    result_type operator()(Generator &gen)
    {
        return impl_(gen);
    }
};

template <class RESULT_TYPE>
class Pseudo_random_engine
        : public Random_engine<RESULT_TYPE>
{
public:
    using result_type = RESULT_TYPE;

    template <class... Args>
    Pseudo_random_engine(Args&&... args);

    result_type next() override;

private:
    Distribution<result_type> distribution_;
    Generator generator_;
};

template <>
class Pseudo_random_engine<bool>
        : public Random_engine<bool>
{
public:
    explicit Pseudo_random_engine(double p_true);

    bool next() override;

private:
    double probability_;
    Distribution<double> distribution_;
    Generator generator_;
};

template <class RESULT_TYPE>
class Stub_random_engine
        : public Random_engine<RESULT_TYPE>
{
public:
    using result_type = RESULT_TYPE;
    using container_type = std::vector<RESULT_TYPE>;
    using iterator_type = typename container_type::const_iterator;

    // PRECONDITION: ! data.empty()
    Stub_random_engine(container_type container);

    result_type next() override;
    bool is_sticky() const override;

private:
    container_type container_;
    iterator_type next_;
};

}  // end namespace random
}  // end namespace detail

/// A generic class for generating [pseudorandom numbers] in uniform
/// distribution over a specified range.
///
/// For example, a @ref Random_source<float> generates `float`s, and a
/// @ref Random_source<int> generates `int`s. To specify a range, pass
/// the bounds to either of the two constructors,
/// @ref Random_source(result_type, result_type) or
/// @ref Random_source(result_type).
/// Then call @ref Random_source::next() on your `Random_source` to generate a
/// random number.
///
/// There are also two constructors available only for particular result types:
///
///   - @ref Random_source(result_type limit) is defined only when result_type
///     is an integral type. It constructs a source that generates numbers from
///     0 up to, but excluding, `limit`.
///
///   - @ref Random_source(double p_true) is defined only when result_type
///     is `bool`. It takes a probability and generates `true` with that
///     probability and `false` otherwise.
///
/// ### Testing
///
/// You can *stub* your Random_source in order to predetermine the sequence of
/// values that it will return. For details, see
/// @ref `Random_source::stub_with(std::initializer_list<result_type>)` and
/// @ref Random_source::stub_with(std::vector<result_type>).
///
/// [pseudorandom numbers]:
///     <https://en.wikipedia.org/wiki/Pseudorandom_number_generator>
template <class RESULT_TYPE>
class Random_source
{
public:
    /// The type of value generated by this Random_source.
    using result_type = RESULT_TYPE;

    /// Constructs a random source that generates values between `min` and
    /// `max`, inclusive.
    ///
    /// Not defined when @ref result_type is `bool`. See
    /// @ref Random_source<bool>::Random_source(double) instead.
    ///
    /// \example
    ///
    /// ```cxx
    /// // Initialize the source to produce `int`s from 1 to 6:
    /// ge211::Random_source<int> six_sided_die(1, 7);
    ///
    /// // Generate a random roll:
    /// int roll_value = six_sided_die.next();
    ///
    /// while (roll_value != 6) {
    ///     std::cout << "You rolled " << roll_value << "; try again.\n";
    ///     roll_value = six_sided_die.next();
    /// }
    ///
    /// std::cout << "Finally rolled a 6!\n";
    /// ```
    IF_COMPILER(DECLARE_IF(!Is_Same<result_type, bool>))
    Random_source(result_type min, result_type max);


    /// Constructs, for integral @ref result_type%s only, a random source that
    /// generates values between `0` and `limit - 1`.
    ///
    /// Thus, %Random_source(limit) is equivalent to
    /// [Random_source][1](0, / limit - 1).
    ///
    /// Not defined when @ref result_type is bool or any non-integral type.
    ///
    /// [1]: @ref Random_source::Random_source(result_type, result_type)
    IF_COMPILER(DECLARE_IF(
            Is_Integral<result_type> &&
            !Is_Same<result_type, bool>))
    explicit Random_source(result_type limit);


    /// Constructs a random source that generates `bool`s, producing `true`
    /// with probability `p_true`.
    ///
    /// Only defined when @ref result_type is `bool`.
    ///
    /// ### Errors
    ///
    ///  - Throws `ge211::Client_logic_error` if `p_true` is less than 0.0 or
    ///    greater than 1.0.
    IF_COMPILER(DECLARE_IF(Is_Same<result_type, bool>))
    explicit Random_source(double p_true);


    /// Returns the next random value from this source.
    ///
    /// \example
    ///
    /// ```cxx
    /// ge211::Random_source<bool> fair_coin(0.5);
    ///
    /// bool flip_1 = fair_coin.next();
    /// bool flip_2 = fair_coin.next();
    /// bool flip_3 = fair_coin.next();
    ///
    /// if (flip_1 && flip_2 && flip_3) {
    ///     std::cout << "All three flips were heads!\n";
    /// } else if (!(flip_1 || flip_2 || flip_3)) {
    ///     std::cout << "All three flips were tails!\n";
    /// }
    /// ```
    result_type next()
    {
        return engine_->next();
    }


    /// Returns the next random value from this source.
    ///
    /// (This is an alias for Random_source::next().
    ///
    /// \example
    ///
    /// ```cxx
    /// void try_it(size_t n_trials)
    /// {
    ///     ge211::Random_source<bool> fair_coin{0.5};
    ///     size_t heads_count = 0;
    ///
    ///     for (size_t i = 0; i < n_trials; ++i) {
    ///         if (fail_coin()) {
    ///             ++heads_count;
    ///         }
    ///     }
    ///
    ///     double heads_frequency = heads_count / (double) n_trials;
    ///
    ///     if (heads_frequency < 0.25 || heads_frequecny > 0.75) {
    ///         std::cout << "Doesn't seem so fair.\n";
    ///     }
    /// }
    /// ```
    result_type operator()()
    {
        return next();
    }


    /// Configures this %Random_source to return a predetermined sequence of
    /// values.
    ///
    /// After passing in a list of values, the Random_source will return those
    /// values in order, and then cycle through them repeatedly if necessary.
    ///
    /// This is intended for testing, in order to make the values chosen by
    /// some component predicable.
    ///
    /// \example
    ///
    /// ```cxx
    /// struct Two_dice
    /// {
    ///     // Source of random die rolls from 1 to 6:
    ///     ge211::Random_source<int> die_source(1, 7);
    ///
    ///     // Rolls both dice and returns their sum.
    ///     int roll();
    /// };
    ///
    /// int Two_dice::roll()
    /// {
    ///     int first = die_source.next();
    ///     int second = die_source.next();
    ///     return first + second;
    /// }
    ///
    /// TEST_CASE("demonstrate random source stubbing")
    /// {
    ///     Model m;
    ///
    ///     // Perform a random roll and check that the result is in the
    ///     // expected range:
    ///     int sum = m.roll();
    ///     CHECK( 2 <= sum && sum <= 12 );
    ///
    ///     // Stub the source to return the given sequence, repeatedly:
    ///     m.die_source.stub_with({1, 2, 3, 4, 5});
    ///
    ///     // Now we can predict the rolls:
    ///     CHECK( m.roll() == 3 );  // rolls 1 and 2
    ///     CHECK( m.roll() == 7 );  // rolls 3 and 4
    ///     CHECK( m.roll() == 6 );  // rolls 5 and 1
    ///     CHECK( m.roll() == 5 );  // rolls 2 and 3
    ///     CHECK( m.roll() == 9 );  // rolls 4 and 5
    ///     CHECK( m.roll() == 3 );  // rolls 1 and 2
    ///     CHECK( m.roll() == 7 );  // rolls 3 and 4
    /// }
    /// ```
    void stub_with(std::initializer_list<result_type> values);


    /// Stubs this %Random_source using a @ref std::vector.
    ///
    /// After passing in a vector of values, the %Random_source will
    /// return those values in order, and then cycle through them repeatedly
    /// if necessary. This works the same as
    /// @ref stub_with(std::initializer_list<result_type>,
    /// so you should see / that function for an example.
    void stub_with(std::vector<result_type> values);


private:
    using Real = detail::random::Pseudo_random_engine<result_type>;
    using Stub = detail::random::Stub_random_engine<std::vector<result_type>>;
    using Engine = detail::random::Random_engine<result_type>;

    std::unique_ptr<Engine> engine_;
};


//
// IMPLEMENTATIONS
//

namespace detail {
namespace random {

using std::begin;
using std::end;

template <class RESULT_TYPE>
bool
Random_engine<RESULT_TYPE>::is_sticky() const
{
    return false;
}

template <class RESULT_TYPE>
template <class... Args>
Pseudo_random_engine<RESULT_TYPE>::Pseudo_random_engine(Args&&... args)
        : distribution_{std::forward<Args>(args)...},
          generator_{construct_generator()}
{ }

template <class RESULT_TYPE>
RESULT_TYPE
Pseudo_random_engine<RESULT_TYPE>::next()
{
    return distribution_(generator_);
}

template <class RESULT_TYPE>
Stub_random_engine<RESULT_TYPE>::Stub_random_engine(container_type container)
        : container_(std::move(container)),
          next_(begin(container_))
{
    if (next_ == end(container)) {
        throw ge211::Client_logic_error{
                "Random_source: cannot stub with empty container"};
    }
}

template <class RESULT_TYPE>
RESULT_TYPE
Stub_random_engine<RESULT_TYPE>::next()
{
    result_type result = *next_++;
    if (next_ == end(container_)) next_ = begin(container_);
    return result;
}

template <class RESULT_TYPE>
bool
Stub_random_engine<RESULT_TYPE>::is_sticky() const
{
    return true;
}

}  // end namespace random
}  // end namespace detail

template <class RESULT_TYPE>
IF_COMPILER(DEFINE_IF)
Random_source<RESULT_TYPE>::Random_source(result_type min, result_type max)
        : engine_{std::make_unique<Real>(min, max)}
{ }

template <class RESULT_TYPE>
IF_COMPILER(DEFINE_IF)
Random_source<RESULT_TYPE>::Random_source(result_type limit)
        : engine_{std::make_unique<Real>(limit)}
{ }

template <class RESULT_TYPE>
IF_COMPILER(DEFINE_IF)
Random_source<RESULT_TYPE>::Random_source(double p_true)
        : engine_{std::make_unique<Real>(p_true)}
{ }

template <class RESULT_TYPE>
void
Random_source<RESULT_TYPE>::stub_with(std::initializer_list<result_type> values)
{
    stub_with_vector(values);
}

template <class RESULT_TYPE>
void
Random_source<RESULT_TYPE>::stub_with(std::vector<RESULT_TYPE> values)
{
    engine_ = std::make_unique<Stub>(std::move(values));
}

}  // end namespace ge211
